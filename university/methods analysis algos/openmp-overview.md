# Основы работы с `OpenMP`

Наиболее распространенным средством распараллеливания программ, написанных на языках `C`/`C++` и Фортран, в системах с разделяемой памятью служит библиотека `OpenMP`

Библиотека `OpenMP` интегрирована в среду разработки `MS` `Visual Studio`. Для включения директив `OpenMP` необходимо в свойствах проекта поставить галочку

`
Project -> Properties -> Configuration Properties -> C/C++ -> Language -> OpenMP Support -> Yes
`

Также необходимо подключить заголовочный файл `omp.h`

В OpenMP используется следующая модель программирования. В последовательную программу, написанную на "обычном" языке (например, `C`/`C++`) добавляются параллельные конструкции. Программа вначале выполняется как однопоточное приложение (с одним, главным потоком). При объявлении параллельной конструкции порождаются дополнительные потоки (нити), которые работают параллельно. При выходе из параллельной конструкции дополнительные потоки завершают работу, и продолжает выполняться только главный поток.

```c++
#pragma omp parallel num_threads(4)
{
    (...)
}
```

В приведенном выше примере директива `#pragma omp parallel` служит объявлением параллельной секции. Опция `num_threads` служит для задания числа параллельных потоков (нитей). В нашем примере – `4` потока. При этом число порождаемых нитей в `OpenMP` не может превышать число физических устройств в системе. Узнать максимально возможное число потоков `OpenMP` на компьютере можно с помощью функции `omp_get_max_threads()`. Весь код, помещенный между фигурными скобочками, будет выполняться одновременно всеми потоками (параллельно). После закрытия фигурной скобочки программа продолжит выполняться в последовательном режиме.

Распараллеливание предполагает, что потоки должны выполнять различные части программы. Для этого необходимо отличать потоки друг от друга и распределить вычисления между ними. Это сделать можно, например, используя номер (ранг) потока.

```c++
#pragma omp parallel num_threads(4)
{
    // определения номера потока
    int rank = omp_get_thread_num();

    if (rank==0)
    {
        // вычисления для потока с номером 0
        (...)
    }
    if (rank==1)
    {
        // вычисления для потока с номером 1
        (...)
    }
    if (rank==2)
    {
        // вычисления для потока с номером 2
        (...)
    }
    if (rank==3)
    {
        // вычисления для потока с номером 3
        (...)
    }
}
```

В `OpenMP` также можно явно распределить вычисления между потоками с помощью директивы `#pragma omp sections`.

```c++
#pragma omp sections
{
    #pragma omp section
    // вычисления для потока с номером 0
    (...)
    #pragma omp section
    // вычисления для потока с номером 1
    (...)
    #pragma omp section
    // вычисления для потока с номером 2
    (...)
    #pragma omp section
    // вычисления для потока с номером 3
    (...)
}
```

Приведенные выше конструкции используются, если в программе есть достаточно крупные участки кода, которые можно выполнять независимо друг от друга. Однако основная доля внутреннего параллелизма в вычислительных программах, как правило, содержится в циклах. Для распараллеливания циклов служит директива `#pragma omp for`. Проиллюстрируем ее применение на примере параллельного линейного комбинирования векторов. Пусть требуется вычислить компоненты вектора `y = a*x + y`.

Последовательная версия:

```c++
void axpy(double a, double *x, double *y, int n)
{
    for (int i=0; i<n; i++)
    {
        y[i] = a*x[i] + y[i];
    }
}
```

Параллельная версия:

```c++
void axpy(double a, double *x, double *y, int n)
{
    #pragma omp parallel
    {
        #pragma omp for
        for (int i=0; i<n; i++)
        {
            y[i] = a*x[i] + y[i];
        }
    }
}
```
